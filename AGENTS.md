# Datadog Terraform Provider

For setup, building, and contribution guidelines, read [DEVELOPMENT.md](./DEVELOPMENT.md) first.

## Critical Rules

### NEVER Use Raw Go Commands for Testing

```bash
# ALWAYS use Makefile targets:
make test                                              # Unit tests
RECORD=false TESTARGS="-run TestName" make testacc     # Acceptance tests

# Recording modes for acceptance tests:
# RECORD=false  - Use cassettes (fast, default)
# RECORD=true   - Record new cassettes
# RECORD=none   - Live API only
```

Raw `go test` bypasses `gotestsum` and test infrastructure.

### Testing Details

For full testing details (unit vs acceptance, RECORD modes, examples), see [TESTING.md](./TESTING.md). The Claude test runner skill also includes expanded test-running guidance.

### ALWAYS Add Schema Descriptions

All schema attributes MUST have `Description` fields - required for `make docs` generation.

## Project Structure

- `datadog/fwprovider/` - Framework resources, search here for new resource patterns
- `datadog/*.go` - SDKv2 resources (legacy), do NOT use for new resources
- `datadog/internal/` - Shared utilities: validators, customtypes, fwutils, planmodifiers
- `datadog/tests/` - Acceptance tests
- `examples/` - HCL examples used by docs generation
- `docs/` - Auto-generated by `make docs`, do NOT edit directly

### Generated Documentation Exceptions

Some docs are manually maintained and excluded from auto generation. Check `scripts/generate-docs.sh` for the current `exclude_files` list before editing any `docs/` files.

## Code Patterns

- ALWAYS search `datadog/fwprovider/` for existing patterns before implementing new ones
- Use Blocks, not Nested Attributes for complex structures
- Avoid ObjectType (breaks docs generation - no field description support)

## Quality Gates

### Quick Checks (before any commit)

- [ ] `make fmtcheck` passes
- [ ] `make test` passes

### Full Validation (before push)

- [ ] `make docs && make check-docs` passes
- [ ] `make vet` and `make errcheck` pass
- [ ] Acceptance tests pass with `RECORD=none` for changed resources
- [ ] No sensitive data in logs or errors

## PR Labels

- Changelog: `improvement`, `feature`, `bugfix`, `note`, or `no-changelog`
- Title prefix: `[datadog_resource_name] Description`

---

## Dashboard Resource: FieldSpec Bidirectional Mapping System

`datadog/dashboardmapping/` contains a mapping-driven architecture
instead of the legacy paired `build*()`/`flatten*()` functions. Understanding this
system is essential before modifying or extending the dashboard v2 resource.

### Resource Versions

- `datadog_dashboard` / `datadog_powerpack` — **Original** SDKv2 resources using hand-written
  `build*()`/`flatten*()` functions in `datadog/resource_datadog_dashboard.go` (~11k lines).
  These remain for backward compatibility with existing Terraform state.
- `datadog_dashboard_v2` / `datadog_powerpack_v2` — **FieldSpec engine** resources in
  `datadog/resource_datadog_dashboard_v2.go` and `datadog/resource_datadog_powerpack_v2.go`.
  New development and OpenAPI sync work targets the v2 resources.

The dashboardmapping package is exported (not under `internal/`) so that dd-source
can import the engine for its HCL export API endpoint.

### Package layout

| File | Contents |
|---|---|
| `engine.go` | `FieldSpec`/`WidgetSpec` types, build/flatten engine, CRUD helpers, widget dispatch, post-processing hooks |
| `field_groups.go` | Reusable `[]FieldSpec` groups (widget-scoped), named after OpenAPI `$ref` schemas |
| `field_groups_dashboard.go` | Dashboard top-level field groups (NOT shared with widget specs) |
| `schema_gen.go` | `FieldSpecToSchemaElem`, `FieldSpecsToSchema`, `WidgetSpecToSchemaBlock` — generate `*schema.Schema` from FieldSpec |
| `widgets.go` | All `WidgetSpec` declarations, `allWidgetSpecs` registry, `AllWidgetSchemasMap` |

### How It Works

Each field is declared **once** as a `FieldSpec`. That single declaration drives:
- **HCL → JSON** (when Terraform writes to the API)
- **JSON → HCL** (when Terraform reads from the API)
- **Schema registration** (type, required/optional, description, validation)
- **Docs generation** (`make docs` reads the Description field)

Adding a new field requires editing **one location** only.

### FieldSpec

```go
type FieldSpec struct {
    // JSON mapping
    HCLKey    string      // key in the Terraform schema
    JSONKey   string      // key in the JSON body (defaults to HCLKey if empty)
    JSONPath  string      // dotted path for structural transforms, e.g. "time.live_span"
    Type      FieldType   // TypeString, TypeBool, TypeInt, TypeStringList, TypeBlock, TypeBlockList, ...
    OmitEmpty bool        // if true, omit from JSON when zero value
    Children  []FieldSpec // for TypeBlock / TypeBlockList
    SchemaOnly bool       // if true, register in schema but skip JSON serialization

    // Terraform schema metadata (drives schema registration and docs)
    Description   string
    Required      bool
    Computed      bool
    Default       interface{}
    MaxItems      int
    Sensitive     bool
    Deprecated    string
    ValidValues   []string   // generates ValidateEnumValue validator; appended to Description in docs
    ConflictsWith []string
    UseSet        bool       // use TypeSet instead of TypeList
    ForceNew      bool       // resource replacement when changed
}
```

### WidgetSpec

```go
type WidgetSpec struct {
    HCLKey      string      // e.g. "timeseries_definition"
    JSONType    string      // e.g. "timeseries" (the "type" field in the JSON definition)
    Description string      // outer block description for docs
    Fields      []FieldSpec // widget-specific fields; CommonWidgetFields merged in by engine
}
```

### Naming Convention: FieldSpec Groups Mirror OpenAPI Schema Names

Reusable `[]FieldSpec` variables in `field_groups.go` are named after the OpenAPI
`components/schemas/` entry they correspond to. Each has a comment identifying
the OpenAPI schema and which widget types use it:

```go
// logQueryDefinitionFields corresponds to OpenAPI components/schemas/LogQueryDefinition.
// Used by: log_query, apm_query, rum_query, network_query, security_query,
//          audit_query, profile_metrics_query (same FieldSpec reused for all).
var logQueryDefinitionFields = []FieldSpec{ ... }
```

Key reusable groups and their OpenAPI equivalents (see `field_groups.go` for the full list):

| Go variable | OpenAPI schema | Used by |
|---|---|---|
| `widgetCustomLinkFields` | `WidgetCustomLink` | 13 specific widgets (not all — spec-verified) |
| `widgetAxisFields` | `WidgetAxis` | timeseries, heatmap, distribution, scatterplot |
| `widgetMarkerFields` | `WidgetMarker` | timeseries, distribution, heatmap |
| `widgetEventFields` | `WidgetEvent` | timeseries, heatmap |
| `logQueryDefinitionFields` | `LogQueryDefinition` | 7 query types (log, apm, rum, etc.) |
| `processQueryDefinitionFields` | `ProcessQueryDefinition` | timeseries and others |
| `widgetFormulaFields` | `WidgetFormula` | all formula-capable widgets |
| `standardQueryFields` | (shared subset) | 6 request field lists |
| `DashboardTopLevelFields` | `Dashboard` (top-level) | dashboard resource schema |

`CommonWidgetFields` (exported) is merged into every `WidgetSpec` by the engine and covers
`title`, `title_size`, `title_align`, and `live_span` (→ `time.live_span`).
`custom_link` is **not** in CommonWidgetFields — it is added explicitly only to the
13 widget types that define `custom_links` in the OpenAPI spec.

### Singular/Plural Convention

OpenAPI and JSON use **plural** keys for arrays. Terraform HCL uses **singular** block
names (standard Terraform convention). The `JSONKey` field bridges the gap:

| HCL (singular) | JSON / OpenAPI (plural) |
|---|---|
| `marker` | `markers` |
| `event` | `events` |
| `request` | `requests` |
| `custom_link` | `custom_links` |
| `widget` | `widgets` |
| `group_by` | `group_by` ← unchanged (noun phrase) |

Always set `JSONKey` explicitly for `TypeBlockList` fields where the names differ.

### OmitEmpty Behavior

`OmitEmpty: true` means the field is omitted from the JSON request body when it is
the zero value (empty string, `false`, `0`, nil slice). Cassette recordings are the
ground truth for `OmitEmpty` decisions:

- Fields in the OpenAPI `required` array → typically `OmitEmpty: false`
- Optional fields → typically `OmitEmpty: true`
- Exceptions exist (e.g. `include_zero: false` is always emitted — confirmed by cassette)

When adding a new optional field and the cassette behavior is unknown, default to
`OmitEmpty: true` and flag it in a PR comment for verification.

### Adding a New Field to an Existing Widget or Schema

1. Find the corresponding `[]FieldSpec` variable (named after the OpenAPI schema) in `field_groups.go`
2. Add the `FieldSpec` entry with `HCLKey`, `Type`, `OmitEmpty`, `Description`, and any `ValidValues`
3. **That's it.** `FieldSpecToSchemaElem` auto-generates the schema; no separate `schema.Schema` entry needed
4. If the field belongs to a reusable group, the change propagates to every widget that references it
5. Run `RECORD=false` tests for affected widgets to confirm cassette compatibility
6. If cassettes don't match, check `OmitEmpty`, `JSONKey`, and `Default`

### Adding a New Widget Type

1. Read the widget's OpenAPI schema
2. Identify which properties map to existing reusable FieldSpec groups in `field_groups.go`
3. Write per-widget FieldSpec entries for the remainder
4. Add a `WidgetSpec` to `allWidgetSpecs` in `widgets.go` — `AllWidgetSchemasMap` and `WidgetSpecToSchemaBlock` generate the schema automatically; no changes to `resourceDatadogDashboard()` needed
5. Write an acceptance test and record cassettes with `RECORD=true`

Use the `/dd-dashboard-sync-openapi` skill for a guided workflow that automates
the diff and generation steps.

### Cassette Compatibility

The JSON serialization must be byte-for-byte identical to what was originally recorded.
This works because `json.Marshal` on `map[string]interface{}` produces alphabetically
sorted output, matching how cassettes were originally recorded.

If a `RECORD=false` test fails with a body mismatch, check:
1. `OmitEmpty` — is a field being included/excluded incorrectly?
2. `JSONKey` — is the JSON key correct (including singular vs plural)?
3. `JSONPath` — for structural transforms, is the nesting correct?
4. `Default` — fields with a Default value are always included by Terraform even when not set in HCL
5. `SchemaOnly` — fields that should not be serialized to JSON must have `SchemaOnly: true`
6. Type coercion — integers stored as strings in HCL must be emitted as integers in JSON

The OpenAPI spec is located at:
`/Users/andy.yacomink/go/src/github.com/DataDog/datadog-api-spec/spec/v1/dashboard.yaml`
